工厂方法模式（`Factory Method Pattern`）
====================
### **意图**
> 工厂父类定义了创建产品对象的公共接口，而工厂子类负责生成具体的产品对象。工厂方法让类把实例化**推迟**到子类，由工厂子类来确定实例化哪一个具体产品类。

### **动机**
 在不修改具体工厂类的情况下引进新的产品，如果出现新的产品类型，只需要为这种新的产品创建一个具体的工厂类就可以获得该新产品的实例。这样可以将产品的“实现”从“使用”中解耦，相对于简单工厂模式更加符合“开闭原则”。
 
### **适用性**
工厂方法模式通常适用于以下场景：
- 客户只知道创建产品的工厂名，而不知道具体的产品名。如 格力空调工厂、美的空调工厂等。
- 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
- 客户不关心创建产品的细节，只关心产品的类型。

### **结构**
<div align="center"> <img src="images/13.factoryMethod.png" width="280px"> </div><br>

### **实现**
```java
// 抽象产品
public interface Product {
    void show();
}

// 具体产品A
public class ConcreteProductA implements Product {
    @Override
    public void show() {
        System.out.println("具体产品A。。。");
    }
}
// 抽象工厂
public interface Factory {	
	Product createProduct();
}
// 具体工厂
public class ConcreteFactoryA implements Factory {
	@Override
	public Product createProduct() {
		System.out.println("具体工厂A，new了一个具体产品A");
		return new ConcreteProductA();
	}
}

// 测试客户端
public class TestClient {
    public static void main(String[] args) throws Exception {
        // 具体工厂对象可以注入到Spring中，由Spring容器管理
        Class<?> c = Class.forName("com.dj.pattern.factoryMethod.ConcreteFactoryA");
        FactoryMethod  factory = (FactoryMethod)c.newInstance();
        Product product = factory.createProduct();
        product.show();
    }
}
```
### **应用**


### **总结**
简单工厂把全部的产品类，在一个工厂类中处理，而工厂方法是创建了一个框架，让具体的子工厂生产相应的产品，新增产品时，只需要增加对应的工厂，无须对原工厂进行任何修改，比简单工厂更有弹性。但是，每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这无疑增加了系统的复杂度。


